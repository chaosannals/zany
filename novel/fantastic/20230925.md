# 发展上的负担

## 创造负担

目前社会呈现中间窄的情况。原因在于创造负担。真正获取利益的人其实是管理者，而这部分人其实并不负责创造。创造者被设计成螺丝钉后，脱离了工厂，就失去了创造力。原因在于创造负担过重，一个工匠没有了工厂里配置的昂贵工具就无法施展技能。制造芯片的设计都做好了，但是找不到代工厂就生产不了。

社会之所以不发展，就在于分配上，有资源的人没有创造能力。而有潜在产生创造能力的人因为繁重的工作和创造负担，没有成为具有创造能力的人。社会就陷入了一个消减的怪圈。

生产工具被垄断在产业链里。这也就是为什么以前的个人英雄时代不复存在，因为工具都被封印。使用有着昂贵的代价。

这样创造就越来越困难，最后创造者沦为了生产者而已，再也不具备创造力，只有管理者需要他们的生产力了。

## 心智负担

C++ 这语言之所以臭名远播，在于此语言引入了很多概念的同时产生了很多使用麻烦的问题，平添了很多心智负担。在有包管理库的语言，引入包就可以使用，而且大部分包引入方式是一致的。而 C++ 你就得为包写引入脚本，谷歌的 C++ 项目里导出是构建脚本和打包脚本。而且谷歌还在不同时期开发了几套构建脚本，使得你只懂 C++ 是不行的，你还要懂各种项目自定义的构建脚本才行。

C++ 语法上也有同样的问题，因为元编程而引入大量语法，编译器就要写得很大，执行起来很慢。这样就增加了调试的负担。没吃要开始调试，先得让编译器跑几分钟，对比前端代码一改就能调试，效率就差太多了。

C++ 的编译流程里面涉及多种编译参数，就拿 Windows 的 MD/MT MDd/MTd 的配置，有些库因为某些原因是没有源码的，所以引入是二进制，此时二进制文件只可能是上面的 四种之一。所以一旦在多重依赖后要链接此库，就只有四分之一的可能是初始配置正确的，不然就会在不知情的情况下报链接错误。而这样就大大增加了开发的心智负担，因为这些工作，本质上和业务无关。

C++ 的编译构造工具，如果修改路径时长会出现缓存问题。

所以很多 C++ 项目都会看到其业务效果都不好，因为开发者可能用了 70% 的精力在应对业务之外的代码，各种构建脚本，编译脚本，打包脚本，发布脚本。

外行可能以为这是运维的事，其实这些高级 C++ 工程师尚且不一定能搞定，

一些人自己没啥贡献却老是要求别人给出贡献，自己做不到，却要求别人去做。这应该是一种策略，副总主管是两个废物。然后就对奔波霸们说你们去把唐僧师徒四人干掉了吧。

一个团体的覆灭就在于任务不断地下放，之后又不断地追责。随后在整个组织里面就被这样传来传去。这种模式是秦代追责机制，这种机制有一个强前提，就是必须绝杀，就是这个责任到了，人必须死。但是放眼现在社会，这个明显不是。所以这种机制会导致各种踢皮球。

此时公司内部人员就会产生一种心智负担，要额外地考虑各种内耗事件。
